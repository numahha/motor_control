# 開ループステップ応答（無負荷）

モータドライバの調整が終わったら、無負荷でのステップ応答を見る。
ここでの主な目的は、「できるだけシンプルand安全な状況でモータの動作確認をする」ことである。
（ステップ応答実験は比較的行いやすい実験である）

ステップ応答を得るためのプログラムは、`test.c`である。大まかに言えば、次の2つの動作を行う。
* 指令電圧：最初の数秒間の指令電圧が0Vで,残りの数秒間に,`INPUT_MAGNITUDE`で指定した大きさ（単位はボルト）の指令電圧を出力
* 角度記録：各時刻でのエンコーダ値から計算されるモータ回転角を記録する。


## ステップ応答のプログラムの動作確認１
まず、DAボード・カウンタボード・モータを使わずに、プログラムの動作確認をする。
`test.c`内の`DA_FLAG`と`ENC_FLAG`の定義がコメントアウトする。
また、`Makefile`内の`LDLIBS`がコメントアウトする。
この状況で、コンパイル・実行する。
```
make
./test
```
`step_responce.dat`という名前で、指令電圧と角度の時系列データが出力されているはずである
（実際にはカウンタボードを使っていないため、角度は全て0として出力している）。
以下のコマンドを実行すると、`curve.png`という名前で指令電圧・角度の時間変化の図が作成される（[例](https://github.com/numahha/motor_control/blob/master/3_step_response/curve_test_without_hw.png)）。
```
python3 plot_result.py
```

## ステップ応答のプログラムの動作確認２
モータは使わずに、プログラム・DAボード・カウンタボードの動作確認をする。
モータの代わりに、前節で使ったセメント抵抗・電流計に繋ぐ。

`test.c`内の`DA_FLAG`と`ENC_FLAG`の定義を有効にする。
また、`Makefile`内の`LDLIBS`を有効にする。
DAボード・カウンタボードのモジュールをロードする（[参照](https://github.com/numahha/interface_ubuntu18/tree/master/a_test_interface)）。
この状況で、コンパイル・実行する。
```
make
./test
```
指令電圧の値に対応した電流計の値となっていればOK。


## ステップ応答（無負荷）の本番
まず、モータの動作の想定を確認しておく。
[技術資料](https://www.hds.co.jp/products/data/pdf/technicaldocument/rotary/RH_Series_supermini_manual_ja_0104-4R-TRH.pdf)より、最大回転速度が100r/min、つまり1分で100回転である。
6秒あたりだと、10回転となる。
そのため、少なくともこの回転速度までは、行儀の良い動作を行うことができると考えられる。
念の為、120r/min（つまり120×2π/60≒12.5rad/s）を超えた場合には自動的にプログラムを終了する機能を書いておく（コード参照）。


エンコーダに直流電源（5~12V）を供給する（[技術資料](https://www.hds.co.jp/products/data/pdf/technicaldocument/rotary/RH_Series_supermini_manual_ja_0104-4R-TRH.pdf)13ページ）。
少しずつ（電圧指令値を通じて）与える電流の大きさを大きくして、プログラムを実行する。
```
make
./test
python3 plot_result.py
```
実験例を、このディレクトリ内の`data.zip`に保存しておく。
* 指令値0.8Vまでは、モータは摩擦で回転しなかった。
* 指令値2.3Vの時、速度リミッターにかかって終了した。


## 定常ゲインの見積もり
（雑な）フィッティングを、`data.zip`の中の`gain.py`と`gain.png`（角速度-トルク関係図）に示す。
ここで、トルク定数のカタログ値2.1(Nm/A)を用いた。
* クーロン摩擦トルクを、0.16(Nm)とする。
* 粘性摩擦係数を、0.0245 (Nm/(rad/s))とする。

## まとめ
* できるだけシンプルand安全な状況でモータの動作確認をした．
* 無負荷であっても，摩擦に勝って動き出すためには、0.8~0.9Vの指令電圧(0.08~0.09Aの電流)が必要。


## 余談：リアルタイム制御
サンプリング周期（`SAMPLING_TIME_US`を通じて指定する）を小さくして実行してみる（例えば1ミリ秒）。
サンプリング周期が小さくしていくと、実行時にその内overrunningという文字が見えるようになる。
これは、forループを実行する周期が守られていないことを意味する。

RT_PREEMPTを使うリアルタイム制御では、
forループを実行する周期をできるだけ守るようにLinuxのスケジューラの優先度を設定する
（コード参照：コメントアウトによってこの機能をオン／オフできるようにしてある）。
これを使うと、小さいサンプリング周期での実行を（ある程度）カバーできるようになる。

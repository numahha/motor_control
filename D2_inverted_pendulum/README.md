# 倒立振子

* （雑に）モデルを組んで、制御設計を行い、適用する。
* 制御設計は、シミュレーションモデルに対して強化学習アルゴリズムを適用して行う。

## モデリング
* 慣性モーメント：板の重さと寸法の測定値から計算する。
* 重力トルク項：板の重さと寸法の測定値、重力定数に基づいて計算する。
* 粘性摩擦：無負荷ステップ応答（電流-角速度）の傾き（つまり定常ゲイン）の測定値に、トルク定数のカタログ値（2.1Nm/A）をかける。
* クーロン摩擦：無負荷ステップ応答（電流-角速度）の切片に、トルク定数のカタログ値（2.1Nm/A）をかける。
* モータ駆動トルクの係数：トルク定数のカタログ値（2.1Nm/A）に、サーボモータの指令電圧-出力電流関係（つまり0.1倍）をかける。
* モータ駆動トルクの最大値：指令電圧±3.0V

## 強化学習
`rl_simulation`のディレクトリを参照

## 実行
強化学習を用いた制御設計を行った後、`result_apply`と`custom_gym`のディレクトリをこの階層にコピーする（前者が学習結果）。

比例フィードバック制御（B4とC4）と同様に、C言語-Python間で共有メモリでやりとりしながら制御を行う。
1つ目のターミナルで`test_c.c`をコンパイルand実行する。
```
make
./test_c.c
```
2つ目のターミナルで、test_py.pyを実行する。
```
python3 test_py.py
```

## 結果
* 一応、倒立はした（動画参照）。
* でも、シミュレーション挙動との比較で、スイングアップの回数が違った。これは、モータが実際に駆動しているトルクがモデルと比較して小さいことを意味している。
* 一つのあり得る原因は、定常ゲインのみを考慮したモータのモデル化（つまり遅れ無し系）としていること。ちゃんと一次遅れ系でモデル化してすれば、より近づくかも？
* ~~上の予想に加えて、モータの特性の理解やカタログ値の使い方を間違えているかも？~~
* それとは別に、なんか相図がガタついている（なぜ？）

![movie](https://github.com/numahha/motor_control/blob/master/D2_inverted_pendulum/pendulum.gif)

## メモ
mpg4からgifに変換するには、
```
ffmpeg -an -i "pendulum.mp4" "pendulum.gif"
```
